"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BottomTabView = BottomTabView;
var _elements = require("@react-navigation/elements");
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeSafeAreaContext = require("react-native-safe-area-context");
var _BottomTabBarHeightCallbackContext = require("../utils/BottomTabBarHeightCallbackContext");
var _BottomTabBarHeightContext = require("../utils/BottomTabBarHeightContext");
var _useAnimatedHashMap = require("../utils/useAnimatedHashMap");
var _BottomTabBar = require("./BottomTabBar");
var _ScreenFallback = require("./ScreenFallback");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const EPSILON = 1e-5;
const STATE_INACTIVE = 0;
const STATE_TRANSITIONING_OR_BELOW_TOP = 1;
const STATE_ON_TOP = 2;
const hasAnimation = options => {
  const {
    animationEnabled,
    transitionSpec
  } = options;
  if (animationEnabled === false || !transitionSpec) {
    return false;
  }
  return true;
};
function BottomTabView(props) {
  const {
    tabBar = props => /*#__PURE__*/React.createElement(_BottomTabBar.BottomTabBar, props),
    state,
    navigation,
    descriptors,
    safeAreaInsets,
    detachInactiveScreens = _reactNative.Platform.OS === 'web' || _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'ios',
    sceneContainerStyle
  } = props;
  const focusedRouteKey = state.routes[state.index].key;

  /**
   * List of loaded tabs, tabs will be loaded when navigated to.
   */
  const [loaded, setLoaded] = React.useState([focusedRouteKey]);
  if (!loaded.includes(focusedRouteKey)) {
    // Set the current tab to be loaded if it was not loaded before
    setLoaded([...loaded, focusedRouteKey]);
  }
  const tabAnims = (0, _useAnimatedHashMap.useAnimatedHashMap)(state);
  React.useEffect(() => {
    const animateToIndex = () => {
      _reactNative.Animated.parallel(state.routes.map((route, index) => {
        const {
          options
        } = descriptors[route.key];
        const {
          transitionSpec
        } = options;
        const animationEnabled = hasAnimation(options);
        const toValue = index === state.index ? 0 : index >= state.index ? 1 : -1;
        if (!animationEnabled || !transitionSpec) {
          return _reactNative.Animated.timing(tabAnims[route.key], {
            toValue,
            duration: 0,
            useNativeDriver: true
          });
        }
        return _reactNative.Animated[transitionSpec.animation](tabAnims[route.key], {
          ...transitionSpec.config,
          toValue,
          useNativeDriver: true
        });
      }).filter(Boolean)).start();
    };
    animateToIndex();
  }, [descriptors, state.index, state.routes, tabAnims]);
  const dimensions = _elements.SafeAreaProviderCompat.initialMetrics.frame;
  const [tabBarHeight, setTabBarHeight] = React.useState(() => (0, _BottomTabBar.getTabBarHeight)({
    state,
    descriptors,
    dimensions,
    layout: {
      width: dimensions.width,
      height: 0
    },
    insets: {
      ..._elements.SafeAreaProviderCompat.initialMetrics.insets,
      ...props.safeAreaInsets
    },
    style: descriptors[state.routes[state.index].key].options.tabBarStyle
  }));
  const renderTabBar = () => {
    return /*#__PURE__*/React.createElement(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, null, insets => tabBar({
      state: state,
      descriptors: descriptors,
      navigation: navigation,
      insets: {
        top: safeAreaInsets?.top ?? insets?.top ?? 0,
        right: safeAreaInsets?.right ?? insets?.right ?? 0,
        bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,
        left: safeAreaInsets?.left ?? insets?.left ?? 0
      }
    }));
  };
  const {
    routes
  } = state;

  // If there is no animation, we only have 2 states: visible and invisible
  const hasTwoStates = !routes.some(route => hasAnimation(descriptors[route.key].options));
  const {
    tabBarPosition = 'bottom'
  } = descriptors[focusedRouteKey].options;
  return /*#__PURE__*/React.createElement(_elements.SafeAreaProviderCompat, {
    style: tabBarPosition === 'left' ? styles.left : tabBarPosition === 'right' ? styles.right : null
  }, tabBarPosition === 'top' ? /*#__PURE__*/React.createElement(_BottomTabBarHeightCallbackContext.BottomTabBarHeightCallbackContext.Provider, {
    value: setTabBarHeight
  }, renderTabBar()) : null, /*#__PURE__*/React.createElement(_ScreenFallback.MaybeScreenContainer, {
    enabled: detachInactiveScreens,
    hasTwoStates: hasTwoStates,
    style: styles.screens
  }, routes.map((route, index) => {
    const descriptor = descriptors[route.key];
    const {
      lazy = true,
      unmountOnBlur,
      sceneStyleInterpolator
    } = descriptor.options;
    const isFocused = state.index === index;
    if (unmountOnBlur && !isFocused) {
      return null;
    }
    if (lazy && !loaded.includes(route.key) && !isFocused && !state.preloadedRouteKeys.includes(route.key)) {
      // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded
      return null;
    }
    const {
      freezeOnBlur,
      header = _ref => {
        let {
          layout,
          options
        } = _ref;
        return /*#__PURE__*/React.createElement(_elements.Header, _extends({}, options, {
          layout: layout,
          title: (0, _elements.getHeaderTitle)(options, route.name)
        }));
      },
      headerShown,
      headerStatusBarHeight,
      headerTransparent
    } = descriptor.options;
    const {
      sceneStyle
    } = sceneStyleInterpolator?.({
      current: tabAnims[route.key]
    }) ?? {};
    const animationEnabled = hasAnimation(descriptor.options);
    const activityState = isFocused ? STATE_ON_TOP // the screen is on top after the transition
    : animationEnabled // is animation is not enabled, immediately move to inactive state
    ? tabAnims[route.key].interpolate({
      inputRange: [0, 1 - EPSILON, 1],
      outputRange: [STATE_TRANSITIONING_OR_BELOW_TOP,
      // screen visible during transition
      STATE_TRANSITIONING_OR_BELOW_TOP, STATE_INACTIVE // the screen is detached after transition
      ],

      extrapolate: 'extend'
    }) : STATE_INACTIVE;
    return /*#__PURE__*/React.createElement(_ScreenFallback.MaybeScreen, {
      key: route.key,
      style: [_reactNative.StyleSheet.absoluteFill, {
        zIndex: isFocused ? 0 : -1
      }],
      active: activityState,
      enabled: detachInactiveScreens,
      freezeOnBlur: freezeOnBlur
    }, /*#__PURE__*/React.createElement(_BottomTabBarHeightContext.BottomTabBarHeightContext.Provider, {
      value: tabBarPosition === 'bottom' ? tabBarHeight : 0
    }, /*#__PURE__*/React.createElement(_elements.Screen, {
      focused: isFocused,
      route: descriptor.route,
      navigation: descriptor.navigation,
      headerShown: headerShown,
      headerStatusBarHeight: headerStatusBarHeight,
      headerTransparent: headerTransparent,
      header: header({
        layout: dimensions,
        route: descriptor.route,
        navigation: descriptor.navigation,
        options: descriptor.options
      }),
      style: [sceneContainerStyle, animationEnabled && sceneStyle]
    }, descriptor.render())));
  })), tabBarPosition !== 'top' ? /*#__PURE__*/React.createElement(_BottomTabBarHeightCallbackContext.BottomTabBarHeightCallbackContext.Provider, {
    value: setTabBarHeight
  }, renderTabBar()) : null);
}
const styles = _reactNative.StyleSheet.create({
  left: {
    flexDirection: 'row-reverse'
  },
  right: {
    flexDirection: 'row'
  },
  screens: {
    flex: 1,
    overflow: 'hidden'
  }
});
//# sourceMappingURL=BottomTabView.js.map